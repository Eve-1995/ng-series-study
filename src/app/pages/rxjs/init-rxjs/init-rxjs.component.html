<app-content-fill>
  <h2 id="resume">概述</h2>
  <p>
    在日常的Angular项目开发中, 一定会用到RxJS, 如果你未曾使用过, 可能会有点担心和焦虑. 放心, 先给你打一针预防针: 绝大部分业务用到的RxJS都很基础! RxJS的确可以做到很复杂的事情,
    但是大部分业务都是搬砖活.了解基本的RxJS就可以应付绝大部分业务了.
  </p>
  <p>
    先记住RxJS的基本概念: <strong>对一个行为的订阅, 并对产生的数据流进行操作处理.</strong> 我知道你读了这句话还是一头雾水, 没关系, just remember it!
  </p>
  <p>
    为了方便理解, 我们先来打个比方. <span class="key-word">假如有一个报社的名字叫A, 而用户B可以对A报社进行预定报纸, 要求每天一份.</span> 这个逻辑够正常够简单吧? 换成RxJS的世界,
    报社A就是可观察对象(Observable),
    而用户B就是观察者(Observer). 订报纸的这个动作, 叫做订阅(Subscription).
  </p>
  <p>有时候, 我们预订报纸并非是想要全部的, 而是有选择性的. 比如只想看科技相关的, 那么当报社按照你的订阅, 每天给你发送报纸的时候, 你会进行过滤. 对Observable进行一些操作的行为,
    我们称之为操作符(Operator)</p>
  <!-- <p>在Angular项目只, RxJS最常用的一个场景, 就是用来发请求. Angular自带的HTTP相关的模块, 在请求后都是返回了一个可观察对象. 所以, 请求就是</p> -->
  <h2>基础案例</h2>
  <div class="section">
    我们来看一个很简单的例子, 该例子演示了如何订阅一个Subject, 如何使用操作符.
    <!-- <code-mirror [code]="appService.code1 | async"></code-mirror> -->
    <app-markdown [src]="'app/pages/rxjs/init-rxjs/children/rxjs-child-03.component.ts'"></app-markdown>
    在组件初始化的时候就对一个Subject进行了订阅. 
    <div class="info">
      Subject你可以理解为就是Observable, 因为他继承了Observable. Subject非常的实用. 他经常用于复杂组件通信. 
    </div>
    下面有个输入框, 你每次的敲击都会让"变更事件"触发, 而 <span class="key-word">ngModelChange</span> 激活后, 会触发 Subject的next事件. 查看 <span class="key-word">demo1Change</span> 的代码逻辑, <span class="key-word">changeTimes</span> 立刻进行了自增. 之后触发了 <span class="key-word">demo1Subject$</span> 的事件, 那么所有订阅了他的地方都会收到通知执行订阅的回调函数. 也就是执行 <span class="key-word">this.count++;</span> 但是不同的是, 订阅时使用了 <span class="key-word">debounceTime</span> 进行过滤, 也就是防抖. 此处的防抖操作符就相当于是你对报社发送的报纸进行过滤.
  </div>
  <h3>运行结果</h3>
  <nz-card class="card demo1">
    <div nz-row>
      <div nz-col nzSpan="24">
        <app-rxjs-child-03></app-rxjs-child-03>
      </div>
    </div>
  </nz-card>
  <h2>取消订阅</h2>
  <div class="section">
    我相信你一定看到了一个新的名词: <span class="key-word">取消订阅</span>. 这是因为当你订阅了一个Subject的时候, 每次发生next事件都会触发订阅. 那么请问, 有没有可能发生多次订阅? 比如在组件 <span class="key-word">ngOnInit</span> 钩子中订阅的话. 每次初始化组件时, 就会订阅一次. 那么不就发生多次订阅了吗? 然而, 在组件销毁的时候, 并不会进行取消订阅. 所以你需要手动取消订阅.
  </div>
  <div class="section">
    那么问题来了, 如果不取消订阅会怎么样? 我们看下面这个案例.
    <!-- <nz-tabset>
      <nz-tab nzTitle="html">
        <code-mirror [code]="code1"></code-mirror>
      </nz-tab>
      <nz-tab nzTitle="ts">
        <code-mirror [code]="code2"></code-mirror>
      </nz-tab>
    </nz-tabset> -->
  </div>
  <h3>运行结果</h3>
  <nz-card class="card">
    <div nz-row [nzGutter]="16">
      <div nz-col nzSpan="8">
        <button nz-button nzType="primary" (click)="emit()">发射事件</button>
      </div>
      <div nz-col nzSpan="8">
        <app-rxjs-child-01></app-rxjs-child-01>
      </div>
      <div nz-col nzSpan="8">
        <app-rxjs-child-02></app-rxjs-child-02>
      </div>
    </div>
  </nz-card>
</app-content-fill>